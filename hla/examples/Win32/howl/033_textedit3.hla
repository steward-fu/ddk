// pgm_textedit3-
//
//	This program demonstrates the use of the text editor widget on a form.

program pgm_textedit3;
#linker( "comdlg32.lib" ) 
#linker( "comctl32.lib" )

?@NoDisplay 	:= true;
?@NoStackAlign	:= true;

#includeOnce( "stdlib.hhf" )
#includeOnce( "howl.hhf" )

const
	applicationName := "Text Editor #3";
	formX			:= w.CW_USEDEFAULT;	// Let Windows position this guy
	formY			:= w.CW_USEDEFAULT;
	formW			:= 600;
	formH			:= 600;

type
	findWnd_t:
		class inherits( wForm_t );
		
			var
				messageCode		:dword;
				findWndHandle	:dword;
				searchStr		:string;
				lpfr			:w.FINDREPLACE;
				startAtIndex	:boolean;
				align( 4 );
				searchBuf		:char[256];
				
			override method processMessage;
			
		endclass;
		
	findWnd_p	:pointer to findWnd_t;


static
	align( 4 );
	vmt( findWnd_t );
	
	
// Forward declarations for the onClick widgetProcs that we're going to
// call when an event occurs.

proc copySelection		   	:widgetProc; @forward;
proc cutSelection		   	:widgetProc; @forward;
proc pasteSelection		   	:widgetProc; @forward;
proc clearSelection		   	:widgetProc; @forward;
proc SaveFile			   	:widgetProc; @forward;
proc findText			   	:widgetProc; @forward;
proc OpenFile			   	:widgetProc; @forward;
proc exitHandler			:widgetProc; @forward;

// Here's the main form definition for the app:

wForm( mainAppWindow );

	var
		findWnd		:findWnd_p;
		showState	:boolean;
		align(4);
	
	
	wMainMenu;
	
		wSubMenu( fileMenu, "file" );
	
			wMenuItem( openMenu,  false, "Open", OpenFile );
			wMenuItem( saveMenu,  false, "Save", SaveFile ); 
			wMenuSeparator; 
			wMenuItem( menu_exit, false, "Exit", exitHandler );
			
		endwSubMenu; 
		 
		wSubMenu( editMenu, "edit" );
			
			wMenuItem( copyMenu,   false, "copy",  copySelection ); 
			wMenuItem( cutMenu,    false, "cut",   cutSelection ); 
			wMenuItem( pasteMenu,  false, "paste", pasteSelection ); 
			wMenuItem( clearMenu,  false, "clear", clearSelection ); 
			
		endwSubMenu;
		 
		wSubMenu( searchMenu, "search" );
			
			wMenuItem( findMenu,  false, "find", findText ); 
			
		endwSubMenu;
		 	
	endwMainMenu;
	
	wTextEdit
	(
		TextEdit1,							// text editor name
		"",									// Initial text string
		10,									// x
		10,									// y
		570,								// width
		540,								// height
		0,									// style
		NULL								// on change handler 
	)
	
	
	
	
endwForm


// Must invoke the following macro to emit the code generated by
// the wForm macro:

mainAppWindow_implementation();
	




	




// The moveTextEdit widget proc will move the editBox 
// between y positions 10 and 40.

proc moveTextEdit:widgetProc;
begin moveTextEdit;

	mov( mainAppWindow.TextEdit1, esi );
	(type wTextEdit_t [esi]).get_y();
	if( eax = 10 ) then
	
		stdout.put( "Moving text editor to y-position 40" nl );
		(type wTextEdit_t [esi]).set_y( 40 );
		
	else
	
		stdout.put( "Moving text editor to y-position 10" nl );
		(type wTextEdit_t [esi]).set_y( 10 );
		
	endif;
	
end moveTextEdit;
	


// The hideShowTextEdit widget proc will hide and show TextEdit1.

proc hideShowTextEdit:widgetProc;
begin hideShowTextEdit;

	mov( thisPtr, esi );
	if( mainAppWindow.showState ) then
	
		(type wPushButton_t [esi]).set_text( "Hide TextEdit" );
		mov( false, mainAppWindow.showState );
		stdout.put( "Showing text editor" nl );
		
		mov( mainAppWindow.TextEdit1, esi );
		(type wTextEdit_t [esi]).show();
		
	else		 
	
		(type wPushButton_t [esi]).set_text( "Show TextEdit" );
		mov( true, mainAppWindow.showState );
		stdout.put( "Hiding text editor" nl );
		
		mov( mainAppWindow.TextEdit1, esi );
		(type wTextEdit_t [esi]).hide();
				
	endif;	
	
end hideShowTextEdit;
	


	


// The resizeTextEdit widget proc change the size of the edit box.

proc resizeTextEdit:widgetProc;
static
	state:boolean := true;
	
begin resizeTextEdit;

	mov( mainAppWindow.TextEdit1, esi );
	if( state ) then
	
		mov( false, state );
		(type wTextEdit_t [esi]).resize
		(
			200,
			400
		);
		
	else
	
		(type wTextEdit_t [esi]).resize
		(
			380,
			550
		);
		mov( true, state );
		
	endif;
		
end resizeTextEdit;
	



	
// Here's the menu handlers:

proc copySelection:widgetProc;
begin copySelection;

	mov( mainAppWindow.TextEdit1, esi );
	(type wTextEdit_t [esi]).copy();

end copySelection;



proc cutSelection:widgetProc;
begin cutSelection;

	mov( mainAppWindow.TextEdit1, esi );
	(type wTextEdit_t [esi]).cut();

end cutSelection;



proc pasteSelection:widgetProc;
begin pasteSelection;

	mov( mainAppWindow.TextEdit1, esi );
	(type wTextEdit_t [esi]).paste();

end pasteSelection;



proc clearSelection:widgetProc;
begin clearSelection;

	mov( mainAppWindow.TextEdit1, esi );
	(type wTextEdit_t [esi]).clear();

end clearSelection;






proc SaveFile:widgetProc;
var
	f			:dword;
	length		:dword;
	fileData	:string;
	lpofn		:w.OPENFILENAME;
	fileName	:string;
	fnBuf		:char[1100];
	
begin SaveFile;

	str.init( fnBuf, @size( fnBuf ));
	mov( eax, fileName );
	mov( @size( lpofn ), lpofn.lStructSize );
	mov( NULL, lpofn.hWndOwner );
	mov( howl.howlInstance, eax );
	mov( eax, lpofn.hInstance );
	mov( NULL, lpofn.lpstrFilter );
	mov( NULL, lpofn.lpstrCustomFilter );
	mov( NULL, lpofn.nMaxCustFilter );
	mov( 0, lpofn.nFilterIndex );
	mov( fileName, eax );
	mov( eax, lpofn.lpstrFile );
	mov( (type str.strRec [eax]).maxlen, eax );
	mov( eax, lpofn.nMaxFile );
	mov( NULL, lpofn.lpstrFileTitle );
	mov( 0, lpofn.nMaxFileTitle );
	mov( NULL, lpofn.lpstrInitialDir );
	mov( NULL, lpofn.lpstrTitle );
	mov( w.OFN_LONGNAMES | w.OFN_PATHMUSTEXIST, lpofn.Flags );
	mov( 0, lpofn.nFileOffset );
	mov( 0, lpofn.nFileExtension );
	mov( NULL, lpofn.lpstrDefExt );
	mov( NULL, lpofn.lCustData );
	mov( NULL, lpofn.lpfnHook );
	mov( NULL, lpofn.lpTemplateName );
	
	w.GetSaveFileName( lpofn );
	if( eax ) then
	
		zstr.len( (type zstring fileName) );
		mov( fileName, ecx );
		mov( eax, (type str.strRec [ecx]).length );
				
		mov( mainAppWindow.TextEdit1, esi );
		(type wTextEdit_t [esi]).a_get_text();
		mov( eax, fileData );
		mov( (type str.strRec [eax]).length, eax );
		mov( eax, length );
		
		fileio.openNew( fileName );
		mov( eax, f );
		fileio.write( f, val fileData, length );
		fileio.close( f );
		str.free( fileData ); 
		
	endif;
	
end SaveFile;



proc OpenFile:widgetProc;
var
	lpofn		:w.OPENFILENAME;
	blobData	:blob.t;
	fileName	:string;
	fnBuf		:char[1100];
	
	
readonly
	defExt		:string := "txt";
	filterStr	:char; @nostorage
				byte "Text Files", 0, "*.txt", 0, 0;
	
begin OpenFile;

	str.init( fnBuf, @size( fnBuf ));
	mov( eax, fileName );
	
	mov( @size( lpofn ), lpofn.lStructSize );
	mov( NULL, lpofn.hWndOwner );
	
	mov( howl.howlInstance, eax );
	mov( eax, lpofn.hInstance );
	
	lea( eax, filterStr );
	mov( eax, lpofn.lpstrFilter );
	mov( NULL, lpofn.lpstrCustomFilter );
	mov( NULL, lpofn.nMaxCustFilter );
	mov( 0, lpofn.nFilterIndex );
	
	mov( fileName, eax );
	mov( eax, lpofn.lpstrFile );
	mov( (type str.strRec [eax]).maxlen, eax );
	mov( eax, lpofn.nMaxFile );
	
	mov( NULL, lpofn.lpstrFileTitle );
	mov( 0, lpofn.nMaxFileTitle );
	mov( NULL, lpofn.lpstrInitialDir );
	mov( NULL, lpofn.lpstrTitle );
	mov( w.OFN_LONGNAMES | w.OFN_PATHMUSTEXIST, lpofn.Flags );
	mov( 0, lpofn.nFileOffset );
	mov( 0, lpofn.nFileExtension );
	
	mov( defExt, eax );
	mov( eax, lpofn.lpstrDefExt );
	
	mov( NULL, lpofn.lCustData );
	mov( NULL, lpofn.lpfnHook );
	mov( NULL, lpofn.lpTemplateName );
	
	w.GetOpenFileName( lpofn );

	if( eax ) then
	
		zstr.len( (type zstring fileName) );
		mov( fileName, ecx );
		mov( eax, (type str.strRec [ecx]).length );
		
		stdout.put( "Opening: ", fileName, nl );
		blob.a_load( fileName );
		mov( eax, blobData );
		
		mov( mainAppWindow.TextEdit1, esi );
		(type wTextEdit_t [esi]).set_text( eax );
		blob.free( blobData ); 
		
	endif;
	
end OpenFile;







proc findText:widgetProc;
const
	ths	:text := "(type findWnd_t [esi])";
	
begin findText;

	mov( mainAppWindow.findWnd, esi );
	if( ths.findWndHandle = NULL ) then
	
		stdout.put( "Opening find window" nl );
	
		str.init( ths.searchBuf, @size( findWnd_t.searchBuf ));
		mov( eax, ths.searchStr );
		
		mov( @size( findWnd_t.lpfr ), ths.lpfr.lStructSize );
		mov( mainAppWindow.findWnd, eax );
		mov( (type findWnd_t [eax]).handle, eax );
		mov( eax, ths.lpfr.hWndOwner );
		mov( NULL, ths.lpfr.hInstance );
		mov
		( 
			w.FR_DOWN | w.FR_HIDEWHOLEWORD,
			ths.lpfr.Flags
		);
		mov( ths.searchStr, eax );
		mov( eax, ths.lpfr.lpstrFindWhat );
		mov( (type str.strRec [eax]).maxlen, eax );
		mov( ax, ths.lpfr.wFindWhatLen );
		mov( NULL, ths.lpfr.lpstrReplaceWith );
		mov( 0, ths.lpfr.wReplaceWithLen );
		mov( NULL, ths.lpfr.lCustData );
		mov( NULL, ths.lpfr.lpfnHook );
		mov( NULL, ths.lpfr.lpTemplateName );
		mov( true, ths.startAtIndex );
		
		w._FindText( ths.lpfr );
		push( eax );
		w.SetWindowLong( eax, w.GWL_USERDATA, mainAppWindow.findWnd );
		pop( eax );
		mov( mainAppWindow.findWnd, ecx );
		mov( eax, (type findWnd_t [ecx]).findWndHandle );
		
	else
	
		stdout.put( "Find window is already open" nl );
		
	endif;
	

end findText;
	

// Here's the onClick event handler for our quit button on the form.
// This handler will simply quit the application:

proc exitHandler:widgetProc;
begin exitHandler;

	// Quit the app:
	
	w.PostQuitMessage( 0 );

end exitHandler;


// Here is the message handler for the findWnd_t object.

method findWnd_t.processMessage
( 
	hwnd	:dword; 
	uMsg	:dword; 
	wParam	:dword; 
	lParam	:dword 
);
var
	saveThis	:dword;
	startPosn	:dword;
	endPosn		:dword;
	searchStr	:string;
	editorText	:string;
	editorBuf	:char[32800];
	
begin processMessage;

	mov( esi, saveThis );
	mov( uMsg, eax );
	if( eax = this.messageCode ) then
	
		// If the FR_DIALOGTERM flag is set, then
		// they've pressed the close box or the cancel button.
		// In either case, we're not doing a search.
		
		test( w.FR_DIALOGTERM, this.lpfr.Flags );
		if( @z ) then  // Doing a search
		
			mov( this.lpfr.lpstrFindWhat, eax );
			str.a_cpyz( eax );
			mov( eax, searchStr );
		
			// Probably ought to allocate the editor buffer
			// ourselves rather than do this ugliness, but
			// it's only 32K max, so what the heck.
			
			str.init( editorBuf, @size( editorBuf ));
			mov( eax, editorText );
			mov( mainAppWindow.TextEdit1, esi );
			(type wTextEdit_t [esi]).get_text( editorText );
			
			(type wTextEdit_t [esi]).get_selection( startPosn, endPosn );
			
			// If this.startAtIndex is false, then we start the
			// search one character beyond the caret (because we may be
			// doing a "find next" operation after the previous search).
			// Else we start the search at startPosn.
			
			mov( saveThis, esi );
			if( !this.startAtIndex ) then
			
				inc( startPosn );
				
			endif;
			mov( false, this.startAtIndex );

			// Determine the kind of search we should perform:
		
			xor( ecx, ecx );
			test( w.FR_DOWN, this.lpfr.Flags );
			if( @nz ) then
			
				or( 1, ecx );
				
			endif;
			test( w.FR_MATCHCASE, this.lpfr.Flags );
			if( @nz ) then
			
				or( 2, ecx );
				
			endif;
			
			// Get the current index into the string for
			// the search:
			
			
			switch( ecx );
			
				case( %00 )
				
					// Search backwards, case insensitive
					
					stdout.put
					( 
						"Searching backward/case insensitive for '", 
						searchStr, 
						"' starting at position ", 
						(type uns32 startPosn), 
						nl 
					);
					str.first( editorText, startPosn );	
					str.irindex2( editorText, searchStr );
					
				
				case( %01 )
				
					// Search forward, case insensitive
					
					stdout.put
					( 
						"Searching forward/case insensitive for '", 
						searchStr, 
						"' starting at position ", 
						(type uns32 startPosn), 
						nl 
					);
						
					str.iindex3( editorText, startPosn, searchStr );
					
				case( %10 )
				
					// Search backward, case sensitive
					
					stdout.put
					( 
						"Searching backward/case sensitive for '", 
						searchStr, 
						"' starting at position ", 
						(type uns32 startPosn), 
						nl 
					);
						
					str.first( editorText, startPosn );	
					str.rindex2( editorText, searchStr );
					
				case( %11 )
				
					// Search forward, case sensitive
					
					stdout.put
					( 
						"Searching forward/case sensitive for '", 
						searchStr, 
						"' starting at position ", 
						(type uns32 startPosn), 
						nl 
					);
						
					str.index3( editorText, startPosn, searchStr );
					
			endswitch;
			stdout.put( "Location:", (type int32 eax), nl );
			if( eax <> -1 ) then
			
				mov( searchStr, ecx );
				mov( (type str.strRec [ecx]).length, ecx );
				add( eax, ecx );
				stdout.put
				( 
					"Setting selection to: ", 
					(type uns32 eax), 
					"..", 
					(type uns32 ecx), 
					nl 
				);
				mov( mainAppWindow.TextEdit1, esi );
				(type wTextEdit_t [esi]).setFocus();
				(type wTextEdit_t [esi]).set_selection( eax, ecx );
			
			else
			
				w.MessageBox
				(
					NULL,
					"String not found",
					"Find",
					w.MB_TASKMODAL | w.MB_OK
				);
						
			endif;
			mov( mainAppWindow.TextEdit1, esi );
			(type wTextEdit_t [esi]).scrollCaret();
			
			str.free( searchStr );
			
		else	// Closing dialog box, not doing a search.
		
			mov( NULL, this.findWndHandle );
			mov( true, this.startAtIndex );
			stdout.put( "Find dialog box closing" nl );
			
		endif;
		
	endif;
	xor( eax, eax );
	
end processMessage;




// We'll use the main application form's onCreate method to initialize
// the various buttons on the form.
//
// This could be done in appStart, but better to leave appStart mainly
// as boilerplate code. Also, putting this code here allows us to use
// "this" to access the mainAppWindow fields (a minor convenience).
		
method mainAppWindow_t.onCreate;
var
	thisSave	:mainAppWindow_p;
	findWnd		:findWnd_p;
	
begin onCreate;

	mov( esi, thisSave );
	
	// Initialize the showState data field:
		
	mov( false, this.showState );
	
	// Initialize the findWnd object:
	
	mov( esi, thisSave );
	mem.alloc( @size( findWnd_t ));
	mov( eax, this.findWnd );
	mov( eax, esi );
	(type findWnd_t [esi]).create_wForm
	(
		"findWnd",	   // wwName	:string;
		"",			   // caption	:string;
		0,			   // exStyle	:dword;
		0,			   // style		:dword; 
		this.handle,   // parent	:dword; 										
		0, 			   // x			:dword; 
		0,			   // y			:dword;
		1,			   // width		:dword;
		1,			   // height	:dword;
		0,			   // fillColor	:dword;
		false 		   // visible	:boolean 
	);
	mov( esi, findWnd );			

	mov( &findWnd_t._VMT_, (type findWnd_t [esi])._pVMT_ );
	w.SetWindowLong( (type findWnd_t [esi]).handle, w.GWL_USERDATA, esi );
	
	w.RegisterWindowMessage( "commdlg_FindReplace"  );
	mov( eax, (type findWnd_t [esi]).messageCode );
	
	(type findWnd_t [esi]).hide();
	mov( esi, ecx );
	mainAppWindow.insertWidget( esi );
	mov( ecx, (type wForm_t [ecx]).wBase_private.parentForm );	// Must be self-relative.
	
	mov( thisSave, esi );	// Not really needed here, but for maintainability
	

end onCreate;

	
	
///////////////////////////////////////////////////////////////////////////////
//
//
// The following is mostly boilerplate code for all apps (about the only thing
// you would change is the size of the main app's form)
//
//
///////////////////////////////////////////////////////////////////////////////
//	
// When the main application window closes, we need to terminate the 
// application. This overridden method handles that situation.  Notice the
// override declaration for onClose in the wForm declaration given earlier.
// Without that, mainAppWindow_t would default to using the wVisual_t.onClose
// method (which does nothing). 
		
method mainAppWindow_t.onClose;
begin onClose;
	
	// Tell the winmain main program that it's time to terminate.
	// Note that this message will (ultimately) cause the appTerminate
	// procedure to be called.
	
	w.PostQuitMessage( 0 );
	
	
end onClose;

			   
  
			   
   
// When the application begins execution, the following procedure
// is called.  This procedure must create the main
// application window in order to kick off the execution of the
// GUI application:
  
procedure appStart;
begin appStart;

	push( esi );
	
	// Create the main application window:
	
	mainAppWindow.create_mainAppWindow
	(
		applicationName,		// Window title
		w.WS_EX_CONTROLPARENT,	// Need this to support TAB control selection
		w.WS_OVERLAPPEDWINDOW,	// Style 
		NULL,					// No parent window 									
		formX,					// x-coordinate for window. 
		formY,					// y-coordinate for window.
		formW,					// Width
		formH,					// Height
		howl.bkgColor_g,		// Background color
		true					// Make visible on creation 
	);
	mov( esi, pmainAppWindow );	// Save pointer to main window object.
	pop( esi );

end appStart;



// appTerminate-
//
//	Called when the application is quitting, giving the app a chance
// to clean up after itself.
//
// Note that this is called *after* the mainAppWindow_t.onClose method
// executes (indeed, mainAppWindow_t.onClose, by posting the quit message,
// is what actually causes the program to begin terminating, which leads
// to the execution of this procedure).

procedure appTerminate;
begin appTerminate;
	
	// Clean up the main application's form.
	// Note that this will recursively clean up all the widgets on the form.
	
	mainAppWindow.destroy();
	
end appTerminate;


// appException-
//
// Gives the application the opportunity to clean up before
// aborting when an unhandled exception comes along:

procedure appException
( 
	theException	:dword in eax;
	raiseAdrs		:dword in ebx;
	filename		:string in ecx;
	userCode		:dword in edx;
	lineNum			:uns32 in edi 
);
begin appException;

	raise( eax );

end appException;



// The main program for a HOWL application must 
// call the HowlMainApp procedure.

begin pgm_textedit3;

	// Set up the background and transparent colors that the
	// form will use when registering the window_t class:
	
	w.GetSysColor( w.COLOR_MENU );
	mov( eax, howl.bkgColor_g );
	or( $FF00_0000, eax );
	mov( eax, howl.transparent_g );
	w.CreateSolidBrush( howl.bkgColor_g );
	mov( eax, howl.bkgBrush_g );

	// Start the HOWL Framework Main Program:
	
	HowlMainApp();
	
	// Delete the brush we created earlier:
	
	w.DeleteObject( howl.bkgBrush_g );			
				
end pgm_textedit3;
 